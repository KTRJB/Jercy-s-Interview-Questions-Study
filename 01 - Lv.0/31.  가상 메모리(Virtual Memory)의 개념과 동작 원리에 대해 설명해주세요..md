## 가상메모리란?

- 물리적 메모리 크기에 구애받지 않고, 프로그램이 더 많은 메모리를 사용할 수 있도록 하는 메모리 관리 기법
- 가상 메모리 시스템은 필요한 데이터만을 메모리로 적재하는 '요구 페이징' 방식을 사용

→ 예시) 램의 크기가 8기가이고, 롤을 실행할 때 롤이 10기가 바이트라면 메모리가 부족해서 롤을 실행할 수 없어야 하지만, 여러가지 프로그램을 함께 사용할 수 있다.

![practical-virtual-memory](https://github.com/user-attachments/assets/a9755282-aede-4477-8d31-89ccd1bb35d8)


## 가상 메모리의 주요 목적과 특징

- 물리적 메모리 한계를 벗어난 프로그래밍 환경 제공
- 프로세스 간 메모리 영역 보호 (각 프로세스가 독립된 가상 주소 공간을 가짐)
- 메모리 관리의 유연성 향상
- 운영 시스템의 안정성과 효율성 개선
- 시스템 자원 이용률 최적화

## 핵심 구성 요소

- **페이지(Page)**: 가상 메모리 공간을 일정한 크기로 나눈 블록 (보통 4KB)
- **프레임(Frame)**: 물리적 메모리를 페이지와 동일한 크기로 나눈 블록
- **페이지 테이블**: 가상 페이지와 물리적 프레임 간의 매핑 정보 저장
- **MMU(Memory Management Unit)**: 가상 주소를 물리 주소로 변환하는 하드웨어 장치
- **TLB(Translation Lookaside Buffer)**: 최근 주소 변환 정보를 캐싱하는 고속 메모리

## 주소 변환 과정

1. **가상 주소 생성**: CPU가 가상 주소 생성
2. **주소 분할**: 가상 주소가 페이지 번호와 오프셋으로 분리
    - 가상 주소 = 페이지 번호 + 오프셋
3. **TLB 검색**: MMU가 먼저 TLB에서 페이지 번호 검색(캐시 역할)
4. **TLB 히트 경우**: TLB에서 프레임 번호를 찾으면 바로 물리 주소 계산
5. **TLB 미스 경우**: 페이지 테이블 접근하여 프레임 번호 확인
6. **물리 주소 계산**: 확인된 프레임 번호와 오프셋으로 물리 주소 계산
    - 물리 주소 = 프레임 번호 × 페이지 크기 + 오프셋
7. **메모리 접근**: 계산된 물리 주소로 메모리 접근
    
![virtual-memory-mechanism1](https://github.com/user-attachments/assets/ec42eabc-29a3-4a64-8273-8fc3d33a2c51)

    
### 페이지 폴트(Page Fault) 처리

페이지 폴트는 프로그램이 물리적 메모리에 없는 페이지에 접근할 때 발생합니다.

1. **인터럽트 발생**: CPU가 존재하지 않는 페이지 접근 시도 → 페이지 폴트 인터럽트
2. **운영체제 개입**: 현재 실행 중인 프로세스 일시 중단
3. **디스크에서 페이지 위치 확인**: 필요한 페이지가 디스크의 어디에 있는지 확인
4. **빈 프레임 확인**:
    - 빈 프레임이 있으면: 해당 프레임 사용
    - 빈 프레임이 없으면: 페이지 교체 알고리즘으로 희생 페이지 선정
5. **페이지 교체**: 선정된 희생 페이지를 디스크로 내보내고(페이지 아웃), 필요한 페이지 로드(페이지 인)
6. **페이지 테이블 업데이트**: 새 매핑 정보로 페이지 테이블 갱신
7. **프로세스 재개**: 중단된 명령어부터 실행 재개

### 페이지 교체 알고리즘

메모리가 가득 찼을 때 어떤 페이지를 교체할지 결정하는 알고리즘입니다.

- **FIFO(First-In-First-Out)**: 가장 오래된 페이지 교체
- **LRU(Least Recently Used)**: 가장 오랫동안 사용되지 않은 페이지 교체
- **LFU(Least Frequently Used)**: 사용 빈도가 가장 낮은 페이지 교체
- **클록(Clock) 알고리즘**: 참조 비트를 사용한 LRU 근사 알고리즘








