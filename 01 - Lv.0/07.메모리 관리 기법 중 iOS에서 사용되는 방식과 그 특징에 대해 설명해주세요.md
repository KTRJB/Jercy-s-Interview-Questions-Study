## 1. **iOS의 메모리 관리 기법**

### iOS 메모리 관리의 개요

iOS에서 메모리 관리는 앱의 성능과 안정성을 위해 중요한 요소입니다. 메모리를 적절히 관리하지 못하면 앱이 충돌하거나 성능이 저하될 수 있습니다. iOS는 메모리 관리를 위해 **자동 참조 카운팅(ARC)**이라는 기법을 사용합니다.

---

## 2. **자동 참조 카운팅(ARC)**

### 정의 및 동작 원리

**자동 참조 카운팅(ARC)**는 iOS 및 macOS 앱에서 사용되는 메모리 관리 메커니즘으로, 객체의 생명 주기를 관리하는 역할을 합니다.

### 동작 방식

1. **참조 카운팅(Reference Counting)**  
   - iOS에서 각 객체는 **참조 횟수(Reference Count)**를 유지합니다. 
   - 객체가 생성되면 참조 카운트가 1로 설정됩니다.
   - 다른 객체가 이를 참조하면 참조 카운트가 증가하고, 참조를 해제하면 감소합니다.
   
2. **객체 해제**  
   - 참조 카운트가 0이 되면, 객체는 더 이상 사용되지 않는 것으로 간주되어 메모리에서 해제됩니다.

3. **ARC의 자동화**  
   - ARC는 컴파일러가 코드 작성 중 **retain**, **release**, **autorelease**와 같은 메모리 관리 호출을 자동으로 삽입하는 방식으로 작동합니다.  
   - 이는 개발자가 직접 메모리 해제를 관리해야 했던 **Manual Reference Counting(MRC)**와의 차이점입니다.

---

## 3. **Garbage Collection과의 차이점**

### 1) **동작 방식의 차이**

| 특징           | **자동 참조 카운팅 (ARC)**       | **Garbage Collection (GC)**     |
| ------------ | ------------------------- | ------------------------------- |
| **기본 원리**    | 참조 카운트를 기반으로 메모리 해제       | 비활성 객체를 탐지하기 위해 메모리 그래프를 순회     |
| **해제 시점**    | 참조 카운트가 0이 되는 즉시 메모리 해제   | GC 스레드가 주기적으로 실행될 때 메모리 해제      |
| **동작 위치**    | 컴파일러 수준에서 메모리 관리 호출을 삽입   | 런타임에서 Garbage Collector가 별도로 동작 |
| **대상 객체 탐지** | 객체 간 참조 관계를 추적해 참조 카운트 관리 | 메모리 그래프를 분석하여 참조되지 않는 객체 탐지     |
| **개발자 개입**   | retain/release 호출 필요 없음   | 메모리 해제 관리에 개발자가 개입할 필요 없음       |

### 2) **성능 차이**

| 항목            | **ARC**                             | **GC**                               |
| ------------- | ----------------------------------- | ------------------------------------ |
| **실시간 성능**    | 참조 카운트가 0이 되는 순간 메모리를 즉시 해제하여 예측 가능 | GC는 실행 시점이 불규칙적이며, 앱의 성능에 영향을 줄 수 있음 |
| **추가 리소스 사용** | 별도의 백그라운드 프로세스가 없으므로 리소스 소비가 적음     | 메모리 그래프를 탐색할 때 CPU와 메모리를 추가로 사용      |
| **적합한 환경**    | UI/UX 중심 앱, 실시간 처리가 중요한 환경          | 데이터 중심 앱, 백그라운드 작업이 많은 환경            |

### 3) **안정성 차이**

#### **ARC**
- **순환 참조 문제**  
  - ARC는 참조 카운트를 기반으로 하기 때문에 **순환 참조(Circular Reference)**가 발생하면 객체가 해제되지 않을 수 있습니다.
  - 개발자가 `weak` 또는 `unowned` 참조를 명시적으로 관리해야 합니다.

#### **GC**
- **순환 참조 해결**  
  - GC는 객체 그래프를 순회하면서 참조되지 않는 객체를 탐지하므로, 순환 참조 문제가 자연스럽게 해결됩니다.
  - 하지만, 그래프 탐색의 복잡성이 높아질수록 탐지 시간 및 성능에 영향을 미칠 수 있습니다.

### 4) **메모리 해제 방식의 차이**

| 항목             | **ARC**                  | **GC**                                             |
| -------------- | ------------------------ | -------------------------------------------------- |
| **메모리 해제 시점**  | 참조 카운트가 0이 되는 즉시 메모리를 해제 | 주기적으로 비활성 객체를 탐지하여 메모리를 해제                         |
| **메모리 사용량 변화** | 일정하게 유지됨                 | GC의 주기적 실행으로 인해 메모리 사용량이 순간적으로 증가하거나 감소하는 패턴 발생 가능 |

### 5) **플랫폼별 사용 현황**

| 플랫폼                     | 사용 메커니즘                     |
|----------------------------|-----------------------------------|
| **iOS/macOS(Swift)**        | **ARC**                         |
| **Android(Java, Kotlin)**   | **Garbage Collection**          |
| **Java Applications**       | **Garbage Collection**          |
| **C++ Applications**        | **Manual Memory Management**    |

### 6) **개발자 관점에서의 차이**

| 항목            | **ARC**                         | **GC**                                                    |
| ------------- | ------------------------------- | --------------------------------------------------------- |
| **처리 방식**     | 컴파일 타임에 retain/release 호출 자동 삽입 | 런타임 중 Garbage Collector가 객체 탐지를 수행                        |
| **메모리 관리 책임** | 개발자가 순환 참조를 방지하기 위한 추가 작업 필요    | 메모리 관리와 순환 참조 문제는 Garbage Collector가 자동으로 처리              |
| **성능에 대한 영향** | 메모리 해제 시점이 예측 가능하여 성능에 영향을 덜 미침 | GC 실행 중 성능 저하 가능성이 있으며, 특히 대규모 객체 그래프에서는 성능 문제가 두드러질 수 있음 |

---

## 4. **ARC의 순환 참조 문제와 해결 방법**

### 순환 참조란?

두 개 이상의 객체가 서로를 강한 참조(Strong Reference)로 유지하면서 참조 카운트가 0으로 감소하지 않는 상황입니다. 이로 인해 메모리 누수가 발생할 수 있습니다.

### 해결 방법

1. **약한 참조(Weak Reference)**  
   - 객체 간 강한 참조 대신 **weak** 키워드를 사용해 순환 참조를 방지합니다.  
   - weak 참조는 참조 카운트를 증가시키지 않으며, 참조 대상 객체가 해제되면 nil로 설정됩니다.

2. **비소유 참조(Unowned Reference)**  
   - **unowned** 키워드는 weak와 유사하지만, 대상 객체가 해제되었을 때 nil이 아닌 비정상 동작이 발생할 수 있습니다.  
   - nil 허용이 필요 없는 경우 사용합니다.


---

## 참고문서

• [Apple 공식 문서 - Automatic Reference Counting](https://developer.apple.com/documentation/swift/automatic_reference_counting)

• [iOS Developer Library](https://developer.apple.com/documentation)

• [Medium - ARC와 GC의 차이점](https://medium.com)
