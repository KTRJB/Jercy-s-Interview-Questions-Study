#자료구조의 종류와 iOS 개발에서 자주 사용되는 자료구조에 대해 설명해주세요.

# 답변 간단요약

“자료구조에는 배열, 딕셔너리, 셋, 스택, 큐, 트리, 그래프가 있고, iOS에서는 주로 배열은 테이블뷰의 데이터 표시에, 딕셔너리는 서버 통신 데이터 처리에, 셋은 중복 제거가 필요한 경우에 사용합니다.”

# 자료구조 종류

## Array (배열)

- 동일한 타입의 데이터를 연속된 메모리 공간에 순차적으로 저장하는 자료구조
- 인덱스를 통해 요소에 직접 접근 가능
- 크기가 고정된 정적 배열과 크기가 가변적인 동적 배열로 구분
    
    ![배열](https://github.com/user-attachments/assets/4668cf0d-93fa-4363-af5b-45cf53acd8cc)


### 특징

- 인덱스를 통한 빠른 접근 (시간 복잡도: O(1))
- 순차적인 데이터 저장
- 메모리의 연속성 보장
- 같은 데이터 타입만 저장 가능
- 크기 변경이 어려움 (정적 배열의 경우)

### 시간 복잡도

- 접근(Access): O(1)
- 검색(Search): O(n)
- 삽입(Insertion):
    - 끝에 삽입: O(1)
    - 중간 삽입: O(n)
- 삭제(Deletion):
    - 끝에서 삭제: O(1)
    - 중간 삭제: O(n)

### 장점

- 인덱스를 통한 빠른 접근 가능
- 간단한 구현
- 연속된 메모리 공간 사용으로 캐시 효율성이 좋음
- 요소들의 순서가 보장됨

### 단점

- 크기가 고정되어 있음 (정적 배열)
- 중간 삽입/삭제 시 많은 데이터 이동 필요
- 메모리 낭비 가능성 (배열 크기가 실제 데이터보다 클 경우)
- 연속된 메모리 공간 필요

### 배열의 활용 사례

- 순차적인 데이터 저장 (예: 학생 목록)
- 테이블뷰/컬렉션뷰의 데이터 소스
- 이미지 픽셀 데이터 저장
- 행렬 연산
- 버퍼 구현

### 메모리 관리

- 정적 배열: 컴파일 시점에 크기가 결정되며 변경 불가
- 동적 배열: 런타임에 크기가 조절되며, 용량 초과 시 재할당 발생
    - 일반적으로 현재 크기의 2배로 증가
    - 메모리 재할당 시 성능 저하 발생 가능
        - swift는 기본적으로 모든 배열이 동적 배열
        

---

## LinkedList (연결 리스트)

- 각 노드가 데이터와 다음 노드를 가리키는 참조(포인터)로 구성된 자료구조
- 노드들이 순차적으로 연결되어 데이터를 저장
- 메모리 공간에 연속적으로 저장되지 않음

    ![링크드 리스트](https://github.com/user-attachments/assets/4a48b5b2-0b36-4742-bda3-404bf70dd0d8)


### 연결 리스트의 종류

- 단일 연결 리스트(Singly Linked List): 각 노드가 다음 노드만을 가리킴
- 이중 연결 리스트(Doubly Linked List): 각 노드가 이전과 다음 노드를 모두 가리킴
- 원형 연결 리스트(Circular Linked List): 마지막 노드가 첫 번째 노드를 가리킴

### 시간 복잡도

- 접근/검색: O(n)
- 맨 앞 삽입/삭제: O(1)
- 맨 뒤 삽입: O(1) (tail 포인터가 있는 경우)
- 맨 뒤 삭제: O(n)
- 중간 삽입/삭제: O(n)

### 장점

- 동적인 크기 조절 가능
- 삽입과 삭제가 효율적 (포인터만 변경)
- 메모리 공간을 효율적으로 사용
- 데이터의 순차적인 접근이 용이

### 단점

- 임의 접근이 불가능 (인덱스로 직접 접근 불가)
- 포인터를 위한 추가 메모리 공간 필요
- 캐시 지역성이 낮음
- 역방향 탐색이 어려움 (단일 연결 리스트의 경우)

### 활용 사례

- 스택과 큐의 구현
- 메모리 관리 (메모리 할당/해제)
- 다항식 표현
- 희소 행렬 구현
- 운영체제의 프로세스 관리

---

## Stack (스택)

- LIFO(Last In First Out) 구조의 자료구조
- 데이터의 삽입과 삭제가 한쪽 끝(top)에서만 이루어짐
- 가장 마지막에 들어온 데이터가 가장 먼저 나가는 구조
    
    ![스택](https://github.com/user-attachments/assets/9fd1f06c-4a2f-4f36-a81a-93d70e643a16)


### 주요 연산과 시간 복잡도

- push(요소 추가): O(1)
- pop(요소 제거): O(1)
- peek(top 요소 확인): O(1)
- isEmpty(빈 스택 확인): O(1)

### 스택의 실제 사용 사례

- 함수 호출 스택 관리
- 실행 취소/다시 실행(Undo/Redo)
- 문법 검사(괄호 매칭, 구문 분석)
- DFS(깊이 우선 탐색) 구현
- 계산기 구현(후위 표기식 계산)
- 웹 브라우저의 방문 기록

### 장점

- 구현이 간단
- 데이터의 삽입/삭제가 빠름
- 메모리를 효율적으로 사용
- 데이터의 순서 보존

### 단점

- 중간 데이터에 접근 불가
- 데이터 검색이 어려움
- 크기가 제한적 (메모리의 스택 영역 사용 시)

---

## Queue (큐)

- FIFO(First In First Out) 구조의 자료구조
- 데이터가 큐의 한쪽 끝(rear)에서 삽입되고 다른 쪽 끝(front)에서 삭제
- 가장 먼저 들어온 데이터가 가장 먼저 나가는 구조
    
    ![큐](https://github.com/user-attachments/assets/491a1c73-c304-48d4-a80e-d92d2514a315)


### 큐의 종류

- 선형 큐 (Linear Queue)
    - 기본적인 큐 구조
    - 배열을 이용한 구현시 메모리 낭비 발생 가능
        - 맨앞에서 데이터를 방출할 시 나머지를 다 옮겨야 하기 때문에
- 원형 큐 (Circular Queue)
    - 배열의 처음과 끝이 연결된 형태
    - 메모리를 효율적으로 사용 가능
- 우선순위 큐 (Priority Queue)
    - 데이터에 우선순위를 부여
    - 우선순위가 높은 데이터가 먼저 나감

### 주요 연산과 시간 복잡도

- enqueue(요소 추가): O(1)
- dequeue(요소 제거): O(1)
- peek(front 요소 확인): O(1)
- isEmpty(빈 큐 확인): O(1)

### 큐의 활용 사례

1. 작업 스케줄링
    - 프린터 대기열
    - 프로세스 관리
    - 작업 예약 시스템
2. iOS/Swift 관련
    - DispatchQueue
    - Operation Queue
    - 네트워크 요청 관리
    - 애니메이션 시퀀스
3. 데이터 버퍼링
    - 데이터 스트리밍
    - 입출력 관리
    - 네트워크 패킷 처리
4. 이벤트 처리
    - 사용자 입력 처리
    - 메시지 큐
    - 알림 시스템
5. 너비 우선 탐색(BFS)
    - 그래프 탐색
    - 최단 경로 찾기
    - 네트워크 탐색

### 장점

- 데이터의 순서 보장
- 간단한 구현
- 빠른 삽입과 삭제
- 데이터 흐름 관리에 효율적

### 단점

- 중간 데이터 접근 불가
- 크기가 고정된 경우 메모리 낭비 가능
- 큐가 꽉 찼을 때 더 이상 삽입 불가
- 데이터 검색이 어려움

---

## Tree (트리)

- 계층적 구조를 표현하는 비선형 자료구조
- 노드(Node)들과 노드들을 연결하는 간선(Edge)들로 구성
- 사이클이 없는 연결된 무방향 그래프
    
    ![트리](https://github.com/user-attachments/assets/7ef1e564-3d8c-4c63-8131-ae4a17d90ac8)


### 트리의 구성 요소

1. 노드(Node)
    - 루트 노드: 트리의 최상위 노드
    - 부모 노드: 상위 계층의 노드
    - 자식 노드: 하위 계층의 노드
    - 리프 노드: 자식이 없는 노드
2. 관계
    - 레벨: 루트로부터의 거리
    - 높이: 트리의 최대 레벨
    - 깊이: 특정 노드까지의 경로 길이
    - 서브트리: 특정 노드를 루트로 하는 트리

### 트리의 종류

1. 이진 트리
    - 각 노드가 최대 2개의 자식을 가짐
    - 완전 이진 트리
    - 포화 이진 트리
    - 균형 이진 트리
2. 이진 탐색 트리(BST)
    - 왼쪽 자식 노드 < 부모 노드 < 오른쪽 자식 노드
    - 검색, 삽입, 삭제가 효율적
3. AVL 트리
    - 자동으로 균형을 맞추는 이진 탐색 트리
    - 높이 균형을 유지
4. B-트리
    - 디스크 접근을 최소화하도록 설계
    - 데이터베이스, 파일 시스템에 사용

### 트리의 순회 방법

1. 전위 순회(Preorder)
    - 루트 → 왼쪽 서브트리 → 오른쪽 서브트리
2. 중위 순회(Inorder)
    - 왼쪽 서브트리 → 루트 → 오른쪽 서브트리
3. 후위 순회(Postorder)
    - 왼쪽 서브트리 → 오른쪽 서브트리 → 루트
4. 레벨 순회(Level-order)
    - 각 레벨별로 노드를 순회

### 활용 사례

1. 계층 구조 표현
    - 파일 시스템
    - 조직도
    - UI 뷰 계층
2. 검색 구조
    - 이진 탐색 트리
    - 데이터베이스 인덱싱
    - 검색 엔진
3. 의사 결정
    - 결정 트리
    - 게임 트리
    - AI의 의사결정 구조
4. iOS/Swift 관련
    - UIView 계층 구조
    - Core Data 관계
    - XML/JSON 파싱

### 장점

- 계층적 데이터 표현에 적합
- 효율적인 검색 가능
- 삽입과 삭제가 비교적 용이
- 데이터의 구조화된 저장

### 단점

- 구현이 복잡할 수 있음
- 메모리 사용량이 많을 수 있음
- 비균형 상태에서 성능 저하
- 노드 간 관계 관리 필요

---

## Graph (그래프)

- 노드(Node/Vertex)와 간선(Edge)으로 구성된 자료구조
- 노드 간의 관계를 표현하는 자료구조
- 방향이 있을 수도 있고 없을 수도 있음
- 가중치(Weight)가 있을 수도 있고 없을 수도 있음
    
    ![그래프](https://github.com/user-attachments/assets/b6ddd4e2-8526-47de-8fce-5d07352dfbc7)

### 그래프의 종류

1. 방향성에 따른 분류
    - 무방향 그래프: 양방향으로 이동 가능
    - 방향 그래프: 한쪽 방향으로만 이동 가능
2. 가중치에 따른 분류
    - 가중치 그래프: 간선에 비용이나 가중치가 할당됨
    - 비가중치 그래프: 간선에 가중치가 없음
3. 특수한 형태
    - 완전 그래프: 모든 노드가 서로 연결된 그래프
    - 부분 그래프: 원래 그래프의 일부분
    - 순환 그래프: 사이클이 존재하는 그래프
    - 비순환 그래프: 사이클이 없는 그래프

### 그래프의 표현 방법

1. 인접 행렬
    - 2차원 배열로 표현
    - 노드 간의 연결 관계를 0과 1로 표현
    - 메모리를 많이 사용하지만 빠른 접근 가능
2. 인접 리스트
    - 연결 리스트로 표현
    - 각 노드에 연결된 노드들을 리스트로 저장
    - 메모리 효율적이지만 특정 연결 확인이 느림

### 그래프 탐색 방법

1. 깊이 우선 탐색(DFS)
    - 스택 또는 재귀를 사용
    - 한 방향으로 깊게 탐색
    - 백트래킹이 필요한 경우 유용
2. 너비 우선 탐색(BFS)
    - 큐를 사용
    - 레벨 단위로 탐색
    - 최단 경로 찾기에 유용

### 활용 사례

1. 네트워크
    - 소셜 네트워크
    - 통신 네트워크
    - 도로 네트워크
2. 경로 탐색
    - 내비게이션
    - 최단 경로 찾기
    - 게임의 경로 찾기
3. 추천 시스템
    - 소셜 미디어 추천
    - 상품 추천
    - 친구 추천
4. 순환 검사
    - 교착 상태 검출
    - 순환 참조 검사
    - 의존성 분석

### 장점

- 복잡한 관계 표현 가능
- 다양한 real-world 문제 해결
- 유연한 데이터 구조
- 효율적인 경로 탐색

### 단점

- 구현이 복잡
- 메모리 사용량이 많을 수 있음
- 성능이 데이터 크기에 민감
- 최적화가 어려울 수 있음

---

## Hash Table (해시 테이블)

- 키(Key)와 값(Value)을 매핑하는 자료구조
- 해시 함수를 사용하여 키를 인덱스로 변환
- 평균적으로 O(1) 시간에 삽입, 삭제, 검색 가능
- 직접 주소화 방식을 개선한 자료구조
    
    ![해시](https://github.com/user-attachments/assets/3bb84877-0fdd-496d-bd54-d0bfbce34e64)


### 해시 테이블의 구성 요소

1. 해시 함수
    - 키를 해시 값(인덱스)으로 변환
    - 균등한 분포를 만드는 것이 중요
    - 빠른 계산이 가능해야 함
2. 버킷(슬롯)
    - 실제 데이터가 저장되는 공간
    - 배열의 각 요소를 버킷이라 함
3. 충돌 해결 방식
    - 체이닝(Chaining)
    - 개방 주소법(Open Addressing)

### 충돌 해결 방법

1. 체이닝(Chaining)
    
    ![해시 체이닝](https://github.com/user-attachments/assets/21878b53-9c59-4c2e-b3bf-094fa7988f0e)

    - 구현이 간단
    - 무한정 데이터 저장 가능
    - 같은 버킷에 여러 데이터를 연결 리스트로 저장
        - 로드 팩터(load factor)를 사용하여 해시 테이블의 크기를 동적
        > **로드팩터**
        >   - 해시 테이블의 크기 대비 저장된 데이터의 비율
        >    - Load Factor = (저장된 데이터 수) / (해시 테이블 크기)
        >    - 일반적으로 0.0 ~ 1.0 사이의 값을 가짐
        >    
        >    ### 로드 팩터의 임계값
        >    
        >    - 일반적으로 0.75(75%)를 기준으로 함
        >    - Java의 HashMap: 0.75
        >    - Swift의 Dictionary: ~0.75
        >    
        >    ### 동작 방식
        >    
        >    1. 데이터 추가할 때마다 로드 팩터 계산
        >    2. 임계값 초과 시 해시 테이블 크기 증가
        >        - 보통 현재 크기의 2배로 확장
        >        - 모든 데이터를 새로운 크기에 맞게 재해시(rehashing)
        >    
        >    ### 왜 필요한가?
        >    
        >    1. 성능 최적화
        >        - 너무 높은 로드 팩터: 충돌 증가로 성능 저하
        >        - 너무 낮은 로드 팩터: 메모리 낭비
        >    2. 자동 크기 조정
        >        - 데이터 증가에 따른 자동 확장
        >        - 최적의 성능 유지
        >    3. 충돌 최소화
        >        - 적절한 로드 팩터 유지로 충돌 감소
        >        - 검색 성능 향상
        >    
        >    ### 로드 팩터와 성능의 관계
        >    
        >    - 낮은 로드 팩터 (< 0.5)
        >        - 장점: 충돌 적음, 빠른 검색
        >        - 단점: 메모리 낭비
        >    - 높은 로드 팩터 (> 0.75)
        >        - 장점: 메모리 효율적 사용
        >        - 단점: 충돌 증가, 검색 속도 저하
2. 개방 주소법(Open Addressing)
    
    ![해시 오픈줏고](https://github.com/user-attachments/assets/d1b1595c-2419-4265-b0a4-7baa031d412b)
   
    1. 선형 조사(Linear Probing)
        - 충돌 발생 시 바로 다음 버킷을 순차적으로 검사
        - h(k, i) = (h(k) + i) mod m
        - 가장 단순하지만 군집화 문제 발생
    2. 이차 조사(Quadratic Probing)
        - 충돌 발생 시 제곱수만큼 떨어진 버킷을 검사
        - h(k, i) = (h(k) + i² ) mod m
        - 선형 조사보다 군집화 문제가 덜하지만 여전히 존재
    3. 이중 해시(Double Hashing)
        - 두 개의 해시 함수를 사용
        - h(k, i) = (h₁(k) + i×h₂(k)) mod m
        - 군집화 문제를 효과적으로 해결하지만 계산 비용이 높음

### 시간 복잡도

- 평균 케이스
    - 삽입: O(1)
    - 삭제: O(1)
    - 검색: O(1)
- 최악의 케이스
    - 모든 연산: O(n)
    - 해시 충돌이 많은 경우 발생

### 활용 사례

1. 캐싱
    - 메모리 캐시
    - 웹 캐시
    - 데이터베이스 캐시
2. 데이터베이스 인덱싱
    - 빠른 데이터 검색
    - 중복 검사
3. 자료구조 구현
    - Dictionary/Map
    - Set
    - Cache
4. 실제 응용
    - 블록체인
    - 암호화
    - 패스워드 저장

### 장점

- 빠른 데이터 접근
- 중복 처리가 용이
- 유연한 크기 조정
- 효율적인 검색

### 단점

- 해시 충돌 가능성
- 순서가 보장되지 않음
- 공간 효율성이 떨어질 수 있음
- 해시 함수 의존성

### 해시 함수의 특징

1. 좋은 해시 함수의 조건
    - 계산이 빠름
    - 해시 값이 균등하게 분포
    - 충돌이 적음
2. 대표적인 해시 함수
    - Division Method
    - Multiplication Method
    - Universal Hashing
    - 암호화 해시 함수(SHA, MD5)

---

## Heap (힙)

- 완전 이진 트리 기반의 자료구조
- 부모 노드와 자식 노드 간의 대소 관계가 정해진 자료구조
- 최대 힙(Max Heap)과 최소 힙(Min Heap)으로 구분
- 우선순위 큐를 구현하는데 사용
  
    ![힙](https://github.com/user-attachments/assets/44e1dac4-768f-4885-bfd1-6f6a893c96c6)

### 힙의 종류

1. 최대 힙(Max Heap)
    - 부모 노드가 자식 노드보다 크거나 같음
    - 루트 노드가 가장 큰 값
2. 최소 힙(Min Heap)
    - 부모 노드가 자식 노드보다 작거나 같음
    - 루트 노드가 가장 작은 값

### 시간 복잡도

- 삽입(Insert): O(log n)
- 삭제(Delete): O(log n)
- 검색(Search): O(n)
- 최대/최소값 찾기: O(1)

### 힙의 연산

1. 삽입 과정
    - 마지막 위치에 삽입
    - 부모와 비교하며 교환(heapify-up)
2. 삭제 과정
    - 루트 노드 삭제
    - 마지막 노드를 루트로 이동
    - 자식과 비교하며 교환(heapify-down)

### 활용 사례

1. 우선순위 큐
    - 운영체제의 작업 스케줄링
    - 네트워크 패킷 우선순위 처리
    - 이벤트 관리
2. 정렬
    - 힙 정렬
    - 부분 정렬
3. 알고리즘
    - Dijkstra 최단 경로
    - Prim의 최소 신장 트리
    - 허프만 코딩

### 장점

- 우선순위를 효율적으로 관리
- 최대/최소값 빠른 접근
- 삽입/삭제가 빠름
- 구현이 비교적 간단

### 단점

- 특정 값 검색이 어려움
- 정렬된 순서 유지가 어려움
- 메모리 사용이 비효율적일 수 있음
- 캐시 지역성이 좋지 않음

---

# **iOS 개발에서 자주 사용되는 자료구조**

### Array (배열)

- UITableView, UICollectionView의 데이터 소스로 활용

### Dictionary (딕셔너리)

- API 응답 데이터 처리에 주로 사용
- 설정값이나 환경설정 저장
- 캐시 구현에 활용

### Set (집합)

- 데이터 필터링에 사용
- 중복 제거가 필요한 경우
- 고유 식별자 관리

### NSCache

- 메모리 캐시를 구현할 때 사용
- 이미지 캐싱에 주로 활용
- 메모리 부족 시 자동으로 데이터 제거
- 임시 데이터 저장소로 활용

### Queue (DispatchQueue)

- 비동기 작업 처리
- 백그라운드 작업 관리
- UI 업데이트 처리
- 작업의 순서 관리

### Stack

- 네비게이션 관리
- 실행 취소/다시 실행 기능
- 뷰 계층 구조 관리
- 마지막 작업 추적

### Tree

- 뷰 계층구조 관리
- Core Data 관계 표현
- JSON 데이터 구조화
- 복잡한 데이터 구조 표현

### IndexPath

- TableView, CollectionView의 위치 관리
- 섹션과 로우의 위치 표현
- 데이터의 계층적 위치 표현

### URLComponents

- URL 구성 요소 관리
- API 엔드포인트 구성
- 쿼리 파라미터 처리
- URL 조작 및 생성
